<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Matrix Library: matrix.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Matrix Library
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">matrix.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Matrix creation, algebra and decompositions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for matrix.h:</div>
<div class="dyncontent">
<div class="center"><img src="matrix_8h__incl.png" border="0" usemap="#matrix_8h" alt=""/></div>
<map name="matrix_8h" id="matrix_8h">
</map>
</div>
</div>
<p><a href="matrix_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmatrix.html">matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main matrix type.  <a href="structmatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmatrix__lup.html">matrix_lup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmatrix__qr.html">matrix_qr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abf305b469605fd8253c647f3d277884f"><td class="memItemLeft" align="right" valign="top"><a id="abf305b469605fd8253c647f3d277884f"></a>
typedef struct <a class="el" href="structmatrix.html">matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_t</b></td></tr>
<tr class="separator:abf305b469605fd8253c647f3d277884f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a14e29164fe6714b318d22ec31a979"><td class="memItemLeft" align="right" valign="top"><a id="a99a14e29164fe6714b318d22ec31a979"></a>
typedef struct <a class="el" href="structmatrix__lup.html">matrix_lup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_lup_t</b></td></tr>
<tr class="separator:a99a14e29164fe6714b318d22ec31a979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f267b8861cd86a31882e4cc6f55104"><td class="memItemLeft" align="right" valign="top"><a id="a29f267b8861cd86a31882e4cc6f55104"></a>
typedef struct <a class="el" href="structmatrix__qr.html">matrix_qr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_qr_t</b></td></tr>
<tr class="separator:a29f267b8861cd86a31882e4cc6f55104"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3808b63ae2c6a59bc7e5661f4cafd2ed"><td class="memItemLeft" align="right" valign="top"><a id="a3808b63ae2c6a59bc7e5661f4cafd2ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a3808b63ae2c6a59bc7e5661f4cafd2ed">matrix_lower_triangular</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A)</td></tr>
<tr class="memdesc:a3808b63ae2c6a59bc7e5661f4cafd2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a matrix <code>A</code> is lower triangular. <br /></td></tr>
<tr class="separator:a3808b63ae2c6a59bc7e5661f4cafd2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8098e0ff84c96b488ad54afba67d13c1"><td class="memItemLeft" align="right" valign="top"><a id="a8098e0ff84c96b488ad54afba67d13c1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a8098e0ff84c96b488ad54afba67d13c1">matrix_upper_triangular</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A)</td></tr>
<tr class="memdesc:a8098e0ff84c96b488ad54afba67d13c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a matrix <code>A</code> is upper triangular. <br /></td></tr>
<tr class="separator:a8098e0ff84c96b488ad54afba67d13c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab370408adfaf4f226061b7ea74c45954"><td class="memItemLeft" align="right" valign="top"><a id="ab370408adfaf4f226061b7ea74c45954"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#ab370408adfaf4f226061b7ea74c45954">matrix_diagonal</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A)</td></tr>
<tr class="memdesc:ab370408adfaf4f226061b7ea74c45954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a matrix <code>A</code> is diagonal. <br /></td></tr>
<tr class="separator:ab370408adfaf4f226061b7ea74c45954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad97daa1b997561d7568a06b213d0ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#abad97daa1b997561d7568a06b213d0ff">matrix_fs</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A, <a class="el" href="structmatrix.html">matrix_t</a> *b)</td></tr>
<tr class="memdesc:abad97daa1b997561d7568a06b213d0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a lower triangular system of equations using the forward substitution algorithm.  <a href="#abad97daa1b997561d7568a06b213d0ff">More...</a><br /></td></tr>
<tr class="separator:abad97daa1b997561d7568a06b213d0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7105309534bc7d6560bd5de5d739b686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a7105309534bc7d6560bd5de5d739b686">matrix_bs</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A, <a class="el" href="structmatrix.html">matrix_t</a> *b)</td></tr>
<tr class="memdesc:a7105309534bc7d6560bd5de5d739b686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an upper triangular system of equations using the backward substitution algorithm.  <a href="#a7105309534bc7d6560bd5de5d739b686">More...</a><br /></td></tr>
<tr class="separator:a7105309534bc7d6560bd5de5d739b686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc259d420e7a3d29baca39bf24d96a3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#afc259d420e7a3d29baca39bf24d96a3a">matrix_ge</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A, <a class="el" href="structmatrix.html">matrix_t</a> *b)</td></tr>
<tr class="memdesc:afc259d420e7a3d29baca39bf24d96a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of linear equations \(Ax = b\) using Gaussian elimination (without pivoting).  <a href="#afc259d420e7a3d29baca39bf24d96a3a">More...</a><br /></td></tr>
<tr class="separator:afc259d420e7a3d29baca39bf24d96a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7479f97763962d4ba0735012eafb3c21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a7479f97763962d4ba0735012eafb3c21">matrix_gepp</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A, <a class="el" href="structmatrix.html">matrix_t</a> *b)</td></tr>
<tr class="memdesc:a7479f97763962d4ba0735012eafb3c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of linear equations \(Ax = b\) using Gaussian elimination (with pivoting).  <a href="#a7479f97763962d4ba0735012eafb3c21">More...</a><br /></td></tr>
<tr class="separator:a7479f97763962d4ba0735012eafb3c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b678ba2f6002bc59f4703abaf5a9fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a6b678ba2f6002bc59f4703abaf5a9fb5">matrix_create</a> (uint64_t m, uint64_t n)</td></tr>
<tr class="memdesc:a6b678ba2f6002bc59f4703abaf5a9fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new matrix with <code>m</code> rows and <code>n</code> columns.  <a href="#a6b678ba2f6002bc59f4703abaf5a9fb5">More...</a><br /></td></tr>
<tr class="separator:a6b678ba2f6002bc59f4703abaf5a9fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e78a42d62d2ee921d861b2bb932a7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#ac1e78a42d62d2ee921d861b2bb932a7c">matrix_add</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A, <a class="el" href="structmatrix.html">matrix_t</a> *B)</td></tr>
<tr class="memdesc:ac1e78a42d62d2ee921d861b2bb932a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the matrices <code>A</code> and <code>B</code>, storing the result in the matrix <code>A</code>.  <a href="#ac1e78a42d62d2ee921d861b2bb932a7c">More...</a><br /></td></tr>
<tr class="separator:ac1e78a42d62d2ee921d861b2bb932a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516702d69391115390dadfd82a239a5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a516702d69391115390dadfd82a239a5e">matrix_id</a> (uint64_t n)</td></tr>
<tr class="memdesc:a516702d69391115390dadfd82a239a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new identity matrix of dimension <code>n</code>.  <a href="#a516702d69391115390dadfd82a239a5e">More...</a><br /></td></tr>
<tr class="separator:a516702d69391115390dadfd82a239a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c77b30fb0aa235b17a6137ca9a22aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a71c77b30fb0aa235b17a6137ca9a22aa">matrix_mul</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A, <a class="el" href="structmatrix.html">matrix_t</a> *B)</td></tr>
<tr class="memdesc:a71c77b30fb0aa235b17a6137ca9a22aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new matrix equal to the product of <code>A</code> and <code>B</code>.  <a href="#a71c77b30fb0aa235b17a6137ca9a22aa">More...</a><br /></td></tr>
<tr class="separator:a71c77b30fb0aa235b17a6137ca9a22aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681fe0383775d33134e7d1f9455ba3bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a681fe0383775d33134e7d1f9455ba3bb">matrix_lu</a> (<a class="el" href="structmatrix.html">matrix_t</a> *U)</td></tr>
<tr class="memdesc:a681fe0383775d33134e7d1f9455ba3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the LU decomposition of the given matrix.  <a href="#a681fe0383775d33134e7d1f9455ba3bb">More...</a><br /></td></tr>
<tr class="separator:a681fe0383775d33134e7d1f9455ba3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9651131ce6bace790b4eb79f715817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatrix__lup.html">matrix_lup_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#aac9651131ce6bace790b4eb79f715817">matrix_lupp</a> (<a class="el" href="structmatrix.html">matrix_t</a> *U)</td></tr>
<tr class="memdesc:aac9651131ce6bace790b4eb79f715817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the LU decomposition algorithm (with partial pivoting of rows).  <a href="#aac9651131ce6bace790b4eb79f715817">More...</a><br /></td></tr>
<tr class="separator:aac9651131ce6bace790b4eb79f715817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003fc17a8108fa2fef2b41567305a581"><td class="memItemLeft" align="right" valign="top"><a id="a003fc17a8108fa2fef2b41567305a581"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a003fc17a8108fa2fef2b41567305a581">matrix_row_swap</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A, uint64_t k, uint64_t l)</td></tr>
<tr class="memdesc:a003fc17a8108fa2fef2b41567305a581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the rows <code>k</code> and <code>l</code> in the matrix <code>A</code>. <br /></td></tr>
<tr class="separator:a003fc17a8108fa2fef2b41567305a581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed67f2e946d13d5e269a04e5afeedf6e"><td class="memItemLeft" align="right" valign="top"><a id="aed67f2e946d13d5e269a04e5afeedf6e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#aed67f2e946d13d5e269a04e5afeedf6e">matrix_print</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A)</td></tr>
<tr class="memdesc:aed67f2e946d13d5e269a04e5afeedf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a compact representation of the matrix to stdout. <br /></td></tr>
<tr class="separator:aed67f2e946d13d5e269a04e5afeedf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8c4c18622b1c99a18a5082c699b94d"><td class="memItemLeft" align="right" valign="top"><a id="a7c8c4c18622b1c99a18a5082c699b94d"></a>
<a class="el" href="structmatrix__qr.html">matrix_qr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a7c8c4c18622b1c99a18a5082c699b94d">matrix_reduced_qr</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A)</td></tr>
<tr class="memdesc:a7c8c4c18622b1c99a18a5082c699b94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a reduced QR factorisation of the matrix <code>A</code> using the Gram&ndash;Schmidt orthonormalisation procedure. <br /></td></tr>
<tr class="separator:a7c8c4c18622b1c99a18a5082c699b94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893ca4ce65ae097b8d5d1167dc84d189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a893ca4ce65ae097b8d5d1167dc84d189">matrix_householder</a> (<a class="el" href="structmatrix.html">matrix_t</a> *v)</td></tr>
<tr class="memdesc:a893ca4ce65ae097b8d5d1167dc84d189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Householder reflection with normal vector <code>v</code>.  <a href="#a893ca4ce65ae097b8d5d1167dc84d189">More...</a><br /></td></tr>
<tr class="separator:a893ca4ce65ae097b8d5d1167dc84d189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa197f495ecc0e2d320ba991ffddceb63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatrix__qr.html">matrix_qr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#aa197f495ecc0e2d320ba991ffddceb63">matrix_qr_hh</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A)</td></tr>
<tr class="memdesc:aa197f495ecc0e2d320ba991ffddceb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a QR decomposition of <code>A</code> using the Householder reflections method.  <a href="#aa197f495ecc0e2d320ba991ffddceb63">More...</a><br /></td></tr>
<tr class="separator:aa197f495ecc0e2d320ba991ffddceb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b763efbb57ab953f9e4b6ed8c9bd90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#ad7b763efbb57ab953f9e4b6ed8c9bd90">matrix_transpose</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A)</td></tr>
<tr class="memdesc:ad7b763efbb57ab953f9e4b6ed8c9bd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new matrix equal to the transpose of <code>A</code>.  <a href="#ad7b763efbb57ab953f9e4b6ed8c9bd90">More...</a><br /></td></tr>
<tr class="separator:ad7b763efbb57ab953f9e4b6ed8c9bd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110a8bfee13e6a39f2cc20d83641a4c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a110a8bfee13e6a39f2cc20d83641a4c6">matrix_destroy</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A)</td></tr>
<tr class="memdesc:a110a8bfee13e6a39f2cc20d83641a4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the matrix <code>A</code>.  <a href="#a110a8bfee13e6a39f2cc20d83641a4c6">More...</a><br /></td></tr>
<tr class="separator:a110a8bfee13e6a39f2cc20d83641a4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d3cc678126c9e254c3f2292eea9937"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a76d3cc678126c9e254c3f2292eea9937">matrix_lsq</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A, <a class="el" href="structmatrix.html">matrix_t</a> *b)</td></tr>
<tr class="memdesc:a76d3cc678126c9e254c3f2292eea9937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a vector x minimising the function \(\frac12 \lVert Ax - b \rVert^2\).  <a href="#a76d3cc678126c9e254c3f2292eea9937">More...</a><br /></td></tr>
<tr class="separator:a76d3cc678126c9e254c3f2292eea9937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae8ac488523c525ecb0c4587c8ca9ba"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a7ae8ac488523c525ecb0c4587c8ca9ba">matrix_jacobi</a> (<a class="el" href="structmatrix.html">matrix_t</a> *A, <a class="el" href="structmatrix.html">matrix_t</a> *b, <a class="el" href="structmatrix.html">matrix_t</a> **x, double tol)</td></tr>
<tr class="memdesc:a7ae8ac488523c525ecb0c4587c8ca9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively solves the system \(Ax = b\) where <code>A</code> satisfies certain convergence criteria.  <a href="#a7ae8ac488523c525ecb0c4587c8ca9ba">More...</a><br /></td></tr>
<tr class="separator:a7ae8ac488523c525ecb0c4587c8ca9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Matrix creation, algebra and decompositions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac1e78a42d62d2ee921d861b2bb932a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e78a42d62d2ee921d861b2bb932a7c">&#9670;&nbsp;</a></span>matrix_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the matrices <code>A</code> and <code>B</code>, storing the result in the matrix <code>A</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Note carefully that this will overwrite what is stored in the matrix <code>A</code>, and leave <code>B</code> unchanged. This is to avoid allocating another matrix unnecessarily. If you need to keep the original <code>A</code>, allocate a copy using <code>matrix_clone</code>. </dd></dl>

</div>
</div>
<a id="a7105309534bc7d6560bd5de5d739b686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7105309534bc7d6560bd5de5d739b686">&#9670;&nbsp;</a></span>matrix_bs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix_t</a>* matrix_bs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves an upper triangular system of equations using the backward substitution algorithm. </p>
<p>This function operates analogously to <code>matrix_fs</code>, except this algorithm can be used to solve systems \(Ax = b\) where \(A\) is upper triangular. </p>

</div>
</div>
<a id="a6b678ba2f6002bc59f4703abaf5a9fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b678ba2f6002bc59f4703abaf5a9fb5">&#9670;&nbsp;</a></span>matrix_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix_t</a>* matrix_create </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new matrix with <code>m</code> rows and <code>n</code> columns. </p>
<p>This function initialises an \(m \times n\) zero matrix, allocating space for it on the heap and returning a pointer to the newly created matrix.</p>
<dl class="section warning"><dt>Warning</dt><dd>When you no longer require the matrix, you must use <code>matrix_destroy</code> in order to free the memory used by the matrix. </dd></dl>

</div>
</div>
<a id="a110a8bfee13e6a39f2cc20d83641a4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110a8bfee13e6a39f2cc20d83641a4c6">&#9670;&nbsp;</a></span>matrix_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory used by the matrix <code>A</code>. </p>
<p>This function frees the array of doubles used to store the elements of the matrix and then frees the matrix structure itself. </p>

</div>
</div>
<a id="abad97daa1b997561d7568a06b213d0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad97daa1b997561d7568a06b213d0ff">&#9670;&nbsp;</a></span>matrix_fs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix_t</a>* matrix_fs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a lower triangular system of equations using the forward substitution algorithm. </p>
<p>This function can be used to solve systems of linear equations where the matrix \(L\) is a (square) lower triangular matrix and we wish to find \(x\) such that \(Lx = b\).</p>
<p>Takes a lower triangular \(n \times n\) matrix <code>A</code> and a vector <b></b>(represented as a \( n \times 1 \) matrix) and returns a newly allocated \(n \times 1\) matrix <code>x</code> such that \(Ax = b\).</p>
<p>Example: suppose we wish to solve the system \(Ax = (1, 0)^T\), where A = [1, 0; 2, 1]. The following code will use forward substitution to solve this system. </p><div class="fragment"><div class="line"><a class="code" href="structmatrix.html">matrix_t</a>* A = <a class="code" href="matrix_8h.html#a516702d69391115390dadfd82a239a5e">matrix_id</a>(2);</div><div class="line">matrix_set(A, 1, 0, 2.0);</div><div class="line"><a class="code" href="structmatrix.html">matrix_t</a>* b = <a class="code" href="matrix_8h.html#a6b678ba2f6002bc59f4703abaf5a9fb5">matrix_create</a>(2, 1);</div><div class="line">matrix_set(b, 0, 0, 1.0);</div><div class="line"><a class="code" href="structmatrix.html">matrix_t</a>* x = <a class="code" href="matrix_8h.html#abad97daa1b997561d7568a06b213d0ff">matrix_fs</a>(A, b);</div></div><!-- fragment --> 
</div>
</div>
<a id="afc259d420e7a3d29baca39bf24d96a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc259d420e7a3d29baca39bf24d96a3a">&#9670;&nbsp;</a></span>matrix_ge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix_t</a>* matrix_ge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a system of linear equations \(Ax = b\) using Gaussian elimination (without pivoting). </p>
<p>Given an \(n \times n\) matrix <code>A</code> and a \(n \times 1\) matrix <code>b</code> representing a vector, this function uses Gaussian elimination to find a vector \(x\) such that \(Ax = b\).</p>
<p>The Gaussian elimination algorithm consists of taking the LU decomposition of A, then using backward and forward substitution because we then obtain lower and upper triangular matrices that we can solve to obtain x.</p>
<dl class="section warning"><dt>Warning</dt><dd>As this matrix uses the LU decomposition algorithm (without pivoting), we require all the <em>principal submatrices</em>, i.e. the submatrix consisting of the first j rows and columns, to be non-singular for j = 1 to n. Failing to verify this will result in the LU decomposition algorithm producing errors. This function does <b>not</b> check that the condition is satisfied. </dd></dl>

</div>
</div>
<a id="a7479f97763962d4ba0735012eafb3c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7479f97763962d4ba0735012eafb3c21">&#9670;&nbsp;</a></span>matrix_gepp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix_t</a>* matrix_gepp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a system of linear equations \(Ax = b\) using Gaussian elimination (with pivoting). </p>
<p>For an explanation of the Gaussian elimination algorithm, see <code>matrix_ge</code>. Instead of using LU factorisation without pivoting, this method uses the LU factorisation with "partial pivoting". This algorithm is designed to deal with small or zero diagonal elements (called pivots). The algorithm must divide by the pivots, so small or zero pivots lead to significant numerical instabiliy.</p>
<p>The pivoting looks for a permutation matrix \(P\) to maximise the pivot element by permuting rows, and then calculates the LU decomposition of \(PA\). </p>

</div>
</div>
<a id="a893ca4ce65ae097b8d5d1167dc84d189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893ca4ce65ae097b8d5d1167dc84d189">&#9670;&nbsp;</a></span>matrix_householder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix_t</a>* matrix_householder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Householder reflection with normal vector <code>v</code>. </p>
<p>This function creates a new matrix \( H = I_n - 2 v v^T \) which is called a <em>Householder reflection</em>. This is a reflection by the hyperplane normal to <code>v</code>, which should be given as an \( n \times 1\) matrix. </p>

</div>
</div>
<a id="a516702d69391115390dadfd82a239a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516702d69391115390dadfd82a239a5e">&#9670;&nbsp;</a></span>matrix_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix_t</a>* matrix_id </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new identity matrix of dimension <code>n</code>. </p>
<p>This function allocates a new matrix that is equal to the identity matrix \(I_n\) with 1 on the diagonal and zero elsewhere. As with <code>matrix_create</code>, you must destroy this manually using <code>matrix_destroy</code> after usage. </p>

</div>
</div>
<a id="a7ae8ac488523c525ecb0c4587c8ca9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae8ac488523c525ecb0c4587c8ca9ba">&#9670;&nbsp;</a></span>matrix_jacobi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double matrix_jacobi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively solves the system \(Ax = b\) where <code>A</code> satisfies certain convergence criteria. </p>
<p>In contrast to <code>matrix_ge</code> and related functions, this is an iterative solver to find the solution to a system of linear equations.</p>
<p>As this is an iterative solver, a tolerance <code>tol</code> must be passed which sets when to stop: when the residual \(\lVert Ax - b \rVert \) is less than <code>tol</code>, we terminate.</p>
<p>This function will never iterate more than MAX_ITER times as defined in <code>matrix.c</code> to prevent infinite looping if the process does not converge.</p>
<dl class="section return"><dt>Returns</dt><dd>The 2-norm of the residual \(Ax - b\) for the vector <code>x</code> which stores the solution found.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The iterative method will only converge if certain criteria are satisified by <code>A</code>. If these are not satisfied, the iterations may never converge to the true value. The following are sufficient conditions for the convergence of the Jacobi method:<ul>
<li>the 'strong row sum' criterion, \(|a_{ii}| &gt; \sum_{j \neq i} |a_{ij}|\) for all \(i\)</li>
<li>the 'strong column sum' criterion, formulated analogously to above,</li>
<li>irreducibility and the 'weak row sum' criterion \(|a_{ii}| \geq \sum_{j \neq i} |a_{ij}| for all i, and \)|a_{kk}| &gt; {j  k} |a_{kj}| for some row k. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a76d3cc678126c9e254c3f2292eea9937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d3cc678126c9e254c3f2292eea9937">&#9670;&nbsp;</a></span>matrix_lsq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix_t</a>* matrix_lsq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a vector x minimising the function \(\frac12 \lVert Ax - b \rVert^2\). </p>
<p>This function can be used to obtain a minimiser of the function \(g(x) = \frac12 \lVert Ax - b \rVert^2\) given an \(m \times n\) matrix <code>A</code> and a \(m \times 1\) matrix <code>b</code>. These problems are known as <b>least squares problems</b>.</p>
<p>Internally, this function calculates the reduced QR factorisation of <code>A</code> and then solves the system using backward substitution.</p>
<dl class="section warning"><dt>Warning</dt><dd>We require <code>A</code> to be of full rank or else the solution is not uniquely determined to the least squares problem. </dd></dl>

</div>
</div>
<a id="a681fe0383775d33134e7d1f9455ba3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681fe0383775d33134e7d1f9455ba3bb">&#9670;&nbsp;</a></span>matrix_lu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix_t</a>* matrix_lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the LU decomposition of the given matrix. </p>
<p>See also <code>matrix_ge</code> for discussion of this function. This performs the LU decomposition algorithm without any pivoting.</p>
<dl class="section return"><dt>Returns</dt><dd>A unit lower triangular matrix (i.e. a matrix with 1 on the diagonal and zero above). The upper triangular matrix will be stored in the matrix passed to the function.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This algorithm requires that <code>U</code> has all <em>principal submatrices</em> non-singular, as described in <code>matrix_ge</code>. You must be sure of this before running the algorithm. </dd></dl>

</div>
</div>
<a id="aac9651131ce6bace790b4eb79f715817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9651131ce6bace790b4eb79f715817">&#9670;&nbsp;</a></span>matrix_lupp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix__lup.html">matrix_lup_t</a>* matrix_lupp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the LU decomposition algorithm (with partial pivoting of rows). </p>
<p>Analogously to <code>matrix_lu</code>, this function can be used to find matrices \(L\) and \(U\), where \(L\) is unit lower triangular and \(U\) is upper triangular.</p>
<p>In contrast to <code>matrix_lu</code>, this function also finds a permutation matrix \(P\) such that \(PA = LU\). This approach has the advantage of being able to work with matrices not satisfying the non-singular submatrix criterion. As discussed in <code>matrix_gepp</code>, pivoting the rows of the matrix prevents numerical instability for small (or zero) pivot elements. </p><dl class="section return"><dt>Returns</dt><dd>A structure containing the matrices L and P. The upper triangular matrix is stored in the argument passed to the function. </dd></dl>

</div>
</div>
<a id="a71c77b30fb0aa235b17a6137ca9a22aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c77b30fb0aa235b17a6137ca9a22aa">&#9670;&nbsp;</a></span>matrix_mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix_t</a>* matrix_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new matrix equal to the product of <code>A</code> and <code>B</code>. </p>
<p>The matrices must be of compatible dimension, so if \(A\) is an \(m \times n\) matrix, then \(B\) must be a \(n \times p\) matrix and the function will return a newly allocated \(m \times p\) matrix.</p>
<p>Unlike the <code>matrix_add</code> function, this function allocates a new matrix because, unless <code>A</code> and <code>B</code> are square, the product matrix will not be of the same dimension as <code>A</code> or <code>B</code>. </p>

</div>
</div>
<a id="aa197f495ecc0e2d320ba991ffddceb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa197f495ecc0e2d320ba991ffddceb63">&#9670;&nbsp;</a></span>matrix_qr_hh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix__qr.html">matrix_qr_t</a>* matrix_qr_hh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a QR decomposition of <code>A</code> using the Householder reflections method. </p>
<p>This is an alternative to computing the QR decomposition with <code>matrix_reduced_qr</code>, which uses the Gram&ndash;Schmidt orthonormalisation procedure. The Householder reflections method tends to be numerically more stable than the Gram&ndash;Schmidt method.</p>
<dl class="section return"><dt>Returns</dt><dd>A heap-allocated structure storing newly allocated matrices Q and R as calculated by the algorithm. The original matrix <code>A</code> is left unchanged. </dd></dl>

</div>
</div>
<a id="ad7b763efbb57ab953f9e4b6ed8c9bd90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b763efbb57ab953f9e4b6ed8c9bd90">&#9670;&nbsp;</a></span>matrix_transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatrix.html">matrix_t</a>* matrix_transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatrix.html">matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new matrix equal to the transpose of <code>A</code>. </p>
<p>The transpose of an \( m \times n \) matrix is an \( n \times m \) matrix where \( a_{ij} = b_{ji} \) where \( b_{ij} \) are the elements of the transpose matrix. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
